#!/usr/bin/env python

import argparse
import datetime
import os
import pprint
import sendgrid
import sys
import xml.sax.saxutils
#from typing import List

from tsc.fetcher import TeacherScheduleFetcher
from tsc.tracker import Tracker


# TODO: Make setup.py
def set_lib_path(file):
    parent, bin = os.path.split(os.path.dirname(os.path.abspath(file)))
    for dir in ('lib', ''):
        path = os.path.join(parent, dir)
        if os.path.exists(path):
            sys.path.insert(0, path)
    return parent, bin


parent_dir, bin_dir = set_lib_path(__file__)
import tsc.fetcher
from tsc.models import connect, DBMapper, Schedule
import tsc.log


def create_argument_parser():
    p = argparse.ArgumentParser(
        prog=os.path.basename(__file__),
        description="Teacher schedule fetcher.",
        conflict_handler="resolve"
    )
    p.add_argument(
        "-d", "--dry-run", action="store_true", default=None,
        help="Do not update database.",
    )
    p.add_argument(
        "-l", "--log-level", metavar="LEVEL",
        help="Log level (Default: info)",
    )
    return p


if __name__ == "__main__":
    teacher_ids_str = os.environ.get("TEACHER_IDS")
    if not teacher_ids_str:
        raise(EnvironmentError("Env 'TEACHER_IDS' is not defined."))
    teacher_ids = teacher_ids_str.split(",")
    if not teacher_ids:
        print("TEACHER_IDS is empty, exiting.", file=sys.stderr)
        sys.exit(1)
    arg_parser = create_argument_parser()
    options = arg_parser.parse_args(sys.argv[1:])
    options_dict = options.__dict__
    logger = tsc.log.initialize(options_dict.get("log_level"))

    fetcher = TeacherScheduleFetcher()  # TeacherScheduleFetcher
    app_id = os.environ.get("APP_ID")
    if not app_id:
        raise (EnvironmentError("Env 'APP_ID' is not defined."))
    tracker = Tracker(app_id)  # Tracker
    try:
        conn = connect()
        db = DBMapper(conn)
        schedule_text = ""
        teachers = {}
        schedules_per_teachers = {}
        tracker_futures = []
        for teacher_id in teacher_ids:
            logger.debug("--- teacher_id = {} ---".format(teacher_id))
            teacher, new_schedules = fetcher.fetch(teacher_id)
            logger.debug("name = {}".format(teacher.name))
            db.update_teacher(teacher)

            from_date = datetime.date.today()
            to_date = from_date + datetime.timedelta(days=6)
            old_schedules = db.find_schedules(teacher_id, from_date, to_date)  # type: List[Schedule]
            logger.debug("old_schedules = " + pprint.pformat(old_schedules))
            logger.debug("new_schedules = " + pprint.pformat(new_schedules))

            reservable_schedules = Schedule.get_new_reservable_schedules(old_schedules, new_schedules)
            logger.debug("--- reservable_schedules ---")
            logger.debug(pprint.pformat(reservable_schedules))
            teachers[teacher_id] = teacher
            schedules_per_teachers[teacher_id] = reservable_schedules
            if not options_dict.get("dry_run"):
                db.update_schedules(new_schedules)
            tracker_futures.append(tracker.send_async(teacher))

        mail_text = ""
        for teacher_id in sorted(schedules_per_teachers):
            schedules = schedules_per_teachers[teacher_id]
            if schedules:
                mail_text += "--- Teacher '{0}' reservable schedule ---\n".format(teachers[teacher_id].name)
                mail_text += "PC: http://eikaiwa.dmm.com/teacher/index/{0}/\n".format(teacher_id)
                mail_text += "Mobile: http://eikaiwa.dmm.com/teacher/schedule/{0}/\n".format(teacher_id)
                mail_text += "\n"
                for s in schedules:
                    mail_text += "  " + s.datetime
                    mail_text += "\n"
                mail_text += "\n"
        if mail_text:
            #print("--- mail_text ---")
            #print(mail_text)
            notification_emails = os.environ.get("NOTIFICATION_EMAILS")
            if not notification_emails:
                raise (EnvironmentError("Env 'NOTIFICATION_EMAILS' is not defined."))
            # TODO: APIKEY
            sendgrid_client = sendgrid.SendGridClient(
                os.environ.get("SENDGRID_USERNAME"),
                os.environ.get("SENDGRID_PASSWORD"),
            )
            for email in notification_emails.split(","):
                mail = sendgrid.Mail()
                mail.add_to(email)
                mail.set_from("noreply@lampetty.net")
                mail.set_subject("New teacher's reservable schedule")
                mail_text = xml.sax.saxutils.escape(mail_text)
                mail.set_html(mail_text.replace("\n", "<br>"))
                sendgrid_client.send(mail)

        for future in tracker_futures:
            logger.debug("tracker result = {}".format(future.result()))
    finally:
        fetcher.close()
        tracker.close()
        if conn:
            conn.close()

